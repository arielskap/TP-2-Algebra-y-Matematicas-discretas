<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Actividad 2 - Programación Lineal | UNIR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #333;
            text-align: center;
        }
        #myPlot {
            width: 100%;
            height: 600px;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 5px;
        }
        .enunciado {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border-left: 4px solid #2196F3;
        }
        .enunciado h2 {
            color: #2196F3;
            text-align: left;
        }
        .enunciado h3 {
            color: #555;
            margin-top: 15px;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        @media print {
            .container {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f0f8ff; border-radius: 10px;">
            <img src="https://upload.wikimedia.org/wikipedia/commons/d/df/Logo_UNIR.png" alt="UNIR" style="height: 100px;">
            <h2 style="margin: 5px 0; color: #003366;">Universidad Internacional de La Rioja</h2>
            <h3 style="margin: 5px 0; color: #666;">Álgebra y Matemática Discreta</h3>
            <hr style="margin: 15px auto; width: 50%; border: 1px solid #ddd;">
            <h1 style="margin: 10px 0; color: #003366; font-size: 1.8em;">Actividad 2: Creación y resolución de un problema de programación lineal</h1>
            <p style="margin: 10px 0; font-size: 1.1em;">
                <strong>Alumno:</strong> Ariel Santiago Villarreal Gutiérrez<br>
                <strong>Fecha:</strong> 04/08/2025
            </p>
        </div>
        
        <h1>Problema de Programación Lineal - Desarrollo Inmobiliario</h1>
        
        <div class="enunciado">
            <h2>Enunciado del Problema</h2>
            <p><em>El enunciado estará relacionado al sector inmobiliario ya que es al cual me dedico como programador hoy en día.</em></p>
            
            <h3>Contexto:</h3>
            <p>Imaginemos que trabajas en una empresa desarrolladora inmobiliaria que está planificando un nuevo proyecto en un terreno de 10,000 m². La empresa puede construir dos tipos de propiedades:</p>
            <ul>
                <li><strong>Tipo A:</strong> Departamentos de lujo (120 m² cada uno)</li>
                <li><strong>Tipo B:</strong> Departamentos estándar (80 m² cada uno)</li>
            </ul>
            
            <h3>Variables de decisión:</h3>
            <ul>
                <li>x₁ = número de departamentos tipo A a construir</li>
                <li>x₂ = número de departamentos tipo B a construir</li>
            </ul>
            
            <h3>Función Objetivo: <span style="color: #e91e63; font-size: 0.9em;">[FUNCIÓN OBJETIVO]</span></h3>
            <p>Queremos maximizar las ganancias. Supongamos:</p>
            <ul>
                <li>Ganancia por departamento tipo A: $80,000 USD</li>
                <li>Ganancia por departamento tipo B: $50,000 USD</li>
            </ul>
            <p><strong>Maximizar Z = 80,000x₁ + 50,000x₂</strong></p>
            
            <h3>Restricciones: <span style="color: #e91e63; font-size: 0.9em;">[LAS INECUACIONES]</span></h3>
            <ol>
                <li><strong>Restricción de terreno disponible:</strong><br>
                    120x₁ + 80x₂ ≤ 10,000 (m² totales disponibles)</li>
                <li><strong>Restricción de inversión inicial:</strong><br>
                    La inversión por departamento tipo A es $200,000 y tipo B es $120,000. El presupuesto total es de $15,000,000.<br>
                    200,000x₁ + 120,000x₂ ≤ 15,000,000</li>
                <li><strong>Restricción de demanda del mercado:</strong><br>
                    Los estudios de mercado indican que no se deben construir más de 60 departamentos tipo B.<br>
                    x₂ ≤ 60</li>
                <li><strong>Restricciones de no negatividad:</strong><br>
                    x₁ ≥ 0, x₂ ≥ 0</li>
            </ol>
        </div>
        
        <h2>Punto 2: Dibuja las inecuaciones, la región factible y la función objetivo</h2>
        
        <div class="info" style="margin-bottom: 20px;">
            <h4>Proceso de Construcción de la Gráfica:</h4>
            <div id="procesoGrafica" style="background-color: #f9f9f9; padding: 15px; border-radius: 5px;">
                <!-- Se llenará dinámicamente -->
            </div>
        </div>
        
        <div id="myPlot"></div>
        
        <div class="info">
            <h3>Resumen de la Solución Gráfica</h3>
            <p><strong style="color: #e91e63;">[LAS INECUACIONES]</strong> - Las restricciones del problema:</p>
            <ul>
                <li><strong>120x₁ + 80x₂ ≤ 10,000</strong> (Restricción de terreno)</li>
                <li><strong>200,000x₁ + 120,000x₂ ≤ 15,000,000</strong> (Restricción de presupuesto)</li>
                <li><strong>x₂ ≤ 60</strong> (Restricción de demanda)</li>
                <li><strong>x₁, x₂ ≥ 0</strong> (No negatividad)</li>
            </ul>
            <p><strong style="color: #e91e63;">[FUNCIÓN OBJETIVO]</strong> - Maximizar Z = 80,000x₁ + 50,000x₂</p>
            <p><strong style="color: #e91e63;">[REGIÓN FACTIBLE]</strong> - El área sombreada en azul representa todas las combinaciones válidas de departamentos que cumplen con todas las restricciones.</p>
            <div id="solucionOptima" style="background-color: #fff3cd; padding: 10px; border-radius: 5px; margin-top: 10px;">
                <!-- Se actualizará dinámicamente con JavaScript -->
            </div>
        </div>
        
        <div class="info" style="margin-top: 20px;">
            <h3>Punto 3: Representa el problema en forma estándar</h3>
            
            <h4>Proceso de Conversión a Forma Estándar:</h4>
            <div id="procesoConversion" style="background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                <!-- Se llenará dinámicamente -->
            </div>
            
            <h4>Sistema de Ecuaciones:</h4>
            <div id="formaEstandar" style="background-color: #f0f0f0; padding: 15px; border-radius: 5px; font-family: monospace;">
                <!-- Se llenará dinámicamente -->
            </div>
            
            <h4 style="margin-top: 15px;">Forma Matricial:</h4>
            <div id="formaMatricial" style="background-color: #f0f0f0; padding: 15px; border-radius: 5px; font-family: monospace;">
                <!-- Se llenará dinámicamente -->
            </div>
        </div>
        
        <div class="info" style="margin-top: 20px;">
            <h3>Punto 4: Solución del Problema</h3>
            
            <h4>Método Gráfico - Análisis de Vértices:</h4>
            <div id="analisisVertices" style="background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                <!-- Se llenará dinámicamente -->
            </div>
            
            <h4>Método Simplex - Proceso Completo:</h4>
            <div id="procesoSimplex" style="background-color: #f0f0f0; padding: 15px; border-radius: 5px; margin-bottom: 15px; overflow-x: auto;">
                <!-- Se llenará dinámicamente -->
            </div>
            
            <h4>Solución Final:</h4>
            <div id="solucionProblema" style="background-color: #e8f4f8; padding: 15px; border-radius: 5px;">
                <!-- Se llenará dinámicamente -->
            </div>
        </div>
    </div>

    <script>

        function truncarDecimales(numero, decimales) {
            const multiplicador = Math.pow(10, decimales);
            return Math.trunc(numero * multiplicador) / multiplicador;
        }

        const departamentos_tipo_lujo = 120;
        const departamentos_tipo_estandar = 80;
        const demanda_tipo_estandar = 60;
        const terreno_disponible = 10000;
        const presupuesto_inicial = 15000000;
        const presupuesto_por_departamento_tipo_lujo = 200000;
        const presupuesto_por_departamento_tipo_estandar = 120000;
        const ganancia_por_departamento_tipo_lujo = 80000;
        const ganancia_por_departamento_tipo_estandar = 50000;

        
        const x = [];
        for(let i = 0; i <= 100; i += 0.5) {
            x.push(i);
        }

        const y1 = x.map(xi => (terreno_disponible - departamentos_tipo_lujo*xi) / departamentos_tipo_estandar);

        const y2 = x.map(xi => (presupuesto_inicial - presupuesto_por_departamento_tipo_lujo*xi) / presupuesto_por_departamento_tipo_estandar);

        const y3 = x.map(xi => demanda_tipo_estandar);

        const mejor_punto_departamento = 0
        const punto_corte_primera_restriccion_estandar = terreno_disponible / (mejor_punto_departamento + departamentos_tipo_estandar)
        const punto_corte_primera_restriccion_lujo = terreno_disponible / (departamentos_tipo_lujo + mejor_punto_departamento)

        const punto_corte_segunda_restriccion_estandar = presupuesto_inicial / (mejor_punto_departamento + presupuesto_por_departamento_tipo_estandar)
        const punto_corte_segunda_restriccion_lujo = presupuesto_inicial / (mejor_punto_departamento + presupuesto_por_departamento_tipo_lujo)

        const restricciones_cruzada_terreno = (terreno_disponible  - (departamentos_tipo_estandar * demanda_tipo_estandar)) / departamentos_tipo_lujo
        const restricciones_cruzada_presupuesto = (presupuesto_inicial  - (presupuesto_por_departamento_tipo_estandar * demanda_tipo_estandar)) / presupuesto_por_departamento_tipo_lujo

        const punto_corte_restriccion_lujo = [mejor_punto_departamento, punto_corte_primera_restriccion_lujo, mejor_punto_departamento, punto_corte_segunda_restriccion_lujo, mejor_punto_departamento, restricciones_cruzada_terreno, restricciones_cruzada_presupuesto]
        const punto_corte_restriccion_estandar = [punto_corte_primera_restriccion_estandar, mejor_punto_departamento, punto_corte_segunda_restriccion_estandar, mejor_punto_departamento, demanda_tipo_estandar, demanda_tipo_estandar, demanda_tipo_estandar]
        
        // Función para verificar si un punto es factible
        function esPuntoFactible(x1, x2) {
            // Restricción 1: Terreno
            const restriccion1 = (departamentos_tipo_lujo * x1 + departamentos_tipo_estandar * x2) <= terreno_disponible;
            
            // Restricción 2: Presupuesto
            const restriccion2 = (presupuesto_por_departamento_tipo_lujo * x1 + presupuesto_por_departamento_tipo_estandar * x2) <= presupuesto_inicial;
            
            // Restricción 3: Demanda
            const restriccion3 = x2 <= demanda_tipo_estandar;
            
            // Restricción 4 y 5: No negatividad
            const restriccion4 = x1 >= 0;
            const restriccion5 = x2 >= 0;
            
            // Retornar objeto con detalles
            return {
                esFactible: restriccion1 && restriccion2 && restriccion3 && restriccion4 && restriccion5,
                detalles: {
                    terreno: restriccion1,
                    presupuesto: restriccion2,
                    demanda: restriccion3,
                    x1_positivo: restriccion4,
                    x2_positivo: restriccion5
                },
                valores: {
                    uso_terreno: departamentos_tipo_lujo * x1 + departamentos_tipo_estandar * x2,
                    uso_presupuesto: presupuesto_por_departamento_tipo_lujo * x1 + presupuesto_por_departamento_tipo_estandar * x2
                }
            };
        }

        // Función para evaluar la función objetivo
        function calcularGanancia(x1, x2) {
            return ganancia_por_departamento_tipo_lujo * x1 + ganancia_por_departamento_tipo_estandar * x2;
        }

        // Lista de vértices candidatos
        const verticesCandidatos = [
            {nombre: "Origen", x1: 0, x2: 0},
            {nombre: "Solo estandar (límite demanda)", x1: mejor_punto_departamento, x2: demanda_tipo_estandar},
            {nombre: "Intersección R2-R3", x1: truncarDecimales(restricciones_cruzada_presupuesto, 2), x2: demanda_tipo_estandar},
            {nombre: "Intersección R1-R2", x1: mejor_punto_departamento, x2: punto_corte_primera_restriccion_estandar},
            {nombre: "Solo lujo (límite presupuesto)", x1: punto_corte_segunda_restriccion_lujo, x2: mejor_punto_departamento},
            {nombre: "Solo lujo (límite terreno)", x1: punto_corte_primera_restriccion_lujo, x2: mejor_punto_departamento},
            {nombre: "Intersección R1-R3", x1: truncarDecimales(restricciones_cruzada_terreno, 2), x2: demanda_tipo_estandar},
        ];

        let betterOption = {
            x1: 0,
            x2: 0,
            ganancia: 0
        }

        // Verificar cada vértice
        console.log("=== VERIFICACIÓN DE VÉRTICES ===");
        verticesCandidatos.forEach(vertice => {
            const resultado = esPuntoFactible(vertice.x1, vertice.x2);
            const ganancia = calcularGanancia(vertice.x1, vertice.x2);
            
            console.log(`\n${vertice.nombre} (${vertice.x1}, ${vertice.x2}):`);
            console.log(`  Factible: ${resultado.esFactible ? '✅' : '❌'}`);
            console.log(`  Ganancia: $${ganancia.toLocaleString()}`);
            
            if (!resultado.esFactible) {
                console.log("  Restricciones violadas:");
                if (!resultado.detalles.terreno) console.log(`    - Terreno: usa ${resultado.valores.uso_terreno} > ${terreno_disponible}`);
                if (!resultado.detalles.presupuesto) console.log(`    - Presupuesto: usa ${resultado.valores.uso_presupuesto} > ${presupuesto_inicial}`);
                if (!resultado.detalles.demanda) console.log(`    - Demanda: x2 = ${vertice.x2} > ${demanda_tipo_estandar}`);
            } else if(ganancia > betterOption.ganancia) {
                betterOption = {
                    x1: vertice.x1,
                    x2: vertice.x2,
                    ganancia
                }
            }
        });

        // Encontrar solo los vértices factibles
        const verticesFactibles = verticesCandidatos.filter(v => 
            esPuntoFactible(v.x1, v.x2).esFactible
        );

        console.log("\n=== REGIÓN FACTIBLE ===");
        console.log("Vértices que forman la región factible:");
        verticesFactibles.forEach(v => {
            console.log(`  (${v.x1}, ${v.x2}) - Ganancia: $${calcularGanancia(v.x1, v.x2).toLocaleString()}`);
        });
        // Vértices de la región factible
        const vertices_x = verticesFactibles.map(v => v.x1)
        const vertices_y = verticesFactibles.map(v => v.x2)

        // Región factible (polígono)
        const region_x = [...vertices_x, vertices_x[0]]
        const region_y = [...vertices_y, vertices_y[0]]

        // Líneas de nivel de la función objetivo
        // Z = 80x₁ + 50x₂ = k
        const z_values = [1000000, 2000000, 3000000, 4000000, 5000000, 6000000];
        const iso_lines = z_values.map(z => ({
            x: x,
            y: x.map(xi => (z - ganancia_por_departamento_tipo_lujo*xi) / ganancia_por_departamento_tipo_estandar),
            name: `Z = ${z}`,
            mode: 'lines',
            line: {
                dash: 'dot',
                width: 1,
                color: 'gray'
            },
            showlegend: false
        }));

        // Trazar la gráfica
        const data = [
            // Región factible
            {
                x: region_x,
                y: region_y,
                fill: 'toself',
                fillcolor: 'rgba(0, 100, 200, 0.2)',
                line: {color: 'transparent'},
                name: 'REGIÓN FACTIBLE',
                type: 'scatter'
            },
            // Restricción 1
            {
                x: x,
                y: y1,
                mode: 'lines',
                name: 'R1 = 120x₁ + 80x₂ ≤ 10,000',
                line: {color: 'red', width: 2}
            },
            // Restricción 2
            {
                x: x,
                y: y2,
                mode: 'lines',
                name: 'R2 = 200,000x₁ + 120,000x₂ ≤ 15,000,000',
                line: {color: 'blue', width: 2}
            },
            // Restricción 3
            {
                x: x,
                y: y3,
                mode: 'lines',
                name: 'R3 = x₂ ≤ 60',
                line: {color: 'green', width: 2}
            },
            {
                x: punto_corte_restriccion_lujo,
                y: punto_corte_restriccion_estandar,
                mode: 'markers',
                marker: {
                    size: 12,
                    color: ['purple', 'red', 'purple', 'blue', 'green', 'orange', 'cyan']
                },
                showlegend: false
            },
            {
                x: punto_corte_restriccion_lujo,
                y: punto_corte_restriccion_estandar,
                mode: 'text',
                text: [`(${mejor_punto_departamento}, ${punto_corte_primera_restriccion_estandar})`, `(${truncarDecimales(punto_corte_primera_restriccion_lujo, 2)}, ${mejor_punto_departamento})`, `(${mejor_punto_departamento}, ${punto_corte_segunda_restriccion_estandar})`, `(${truncarDecimales(punto_corte_segunda_restriccion_lujo, 2)}, ${mejor_punto_departamento})`, `(${mejor_punto_departamento}, ${demanda_tipo_estandar})`,`(${truncarDecimales(restricciones_cruzada_terreno, 2)}, ${demanda_tipo_estandar})`, `(${truncarDecimales(restricciones_cruzada_presupuesto, 2)}, ${demanda_tipo_estandar})`],
                textposition: 'top center',
                showlegend: false
            },
            // Vértices
            {
                x: vertices_x,
                y: vertices_y,
                mode: 'markers+text',
                name: 'Vértices',
                marker: {
                    size: 10,
                    color: 'black'
                },
                text: verticesFactibles.map(v => `(${v.x1}, ${v.x2})`),
                textposition: 'top right'
            },
            ...iso_lines
        ];

        const layout = {
            title: 'Problema de Programación Lineal - Desarrollo Inmobiliario',
            xaxis: {
                title: 'x₁ (Departamentos tipo Lujo)',
                range: [-5, 100]
            },
            yaxis: {
                title: 'x₂ (Departamentos tipo Estandar)',
                range: [-5, 150]
            },
            showlegend: true,
            legend: {
                x: 1,
                y: 1
            }
        };

        Plotly.newPlot('myPlot', data, layout);
        
        // Actualizar proceso de construcción de la gráfica
        let htmlProceso = '<ol>';
        htmlProceso += '<li><strong>Cálculo de puntos de corte con los ejes:</strong><br>';
        htmlProceso += '<table style="width: 100%; margin: 10px 0;">';
        htmlProceso += '<tr style="background-color: #e0e0e0;">';
        htmlProceso += '<th style="border: 1px solid #999; padding: 8px;">Restricción</th>';
        htmlProceso += '<th style="border: 1px solid #999; padding: 8px;">Corte con eje x₁ (cuando x₂=0)</th>';
        htmlProceso += '<th style="border: 1px solid #999; padding: 8px;">Corte con eje x₂ (cuando x₁=0)</th>';
        htmlProceso += '</tr>';
        htmlProceso += `<tr><td style="border: 1px solid #999; padding: 8px;">120x₁ + 80x₂ ≤ 10,000</td>`;
        htmlProceso += `<td style="border: 1px solid #999; padding: 8px;">(${punto_corte_primera_restriccion_lujo.toFixed(2)}, 0)</td>`;
        htmlProceso += `<td style="border: 1px solid #999; padding: 8px;">(0, ${punto_corte_primera_restriccion_estandar})</td></tr>`;
        htmlProceso += `<tr><td style="border: 1px solid #999; padding: 8px;">200,000x₁ + 120,000x₂ ≤ 15,000,000</td>`;
        htmlProceso += `<td style="border: 1px solid #999; padding: 8px;">(${punto_corte_segunda_restriccion_lujo}, 0)</td>`;
        htmlProceso += `<td style="border: 1px solid #999; padding: 8px;">(0, ${punto_corte_segunda_restriccion_estandar})</td></tr>`;
        htmlProceso += `<tr><td style="border: 1px solid #999; padding: 8px;">x₂ ≤ 60</td>`;
        htmlProceso += `<td style="border: 1px solid #999; padding: 8px;">Línea horizontal</td>`;
        htmlProceso += `<td style="border: 1px solid #999; padding: 8px;">(0, 60)</td></tr>`;
        htmlProceso += '</table></li>';
        
        htmlProceso += '<li style="margin-top: 15px;"><strong>Determinación de la región factible:</strong><br>';
        htmlProceso += 'Para cada restricción, se verifica qué lado de la recta satisface la desigualdad:<br>';
        htmlProceso += '- 120x₁ + 80x₂ ≤ 10,000: Probando (0,0) → 0 ≤ 10,000 ✓ (debajo de la recta)<br>';
        htmlProceso += '- 200,000x₁ + 120,000x₂ ≤ 15,000,000: Probando (0,0) → 0 ≤ 15,000,000 ✓ (debajo de la recta)<br>';
        htmlProceso += '- x₂ ≤ 60: La región válida está debajo de la línea x₂ = 60<br>';
        htmlProceso += '- x₁, x₂ ≥ 0: Primer cuadrante</li>';
        
        htmlProceso += '<li style="margin-top: 15px;"><strong>Identificación de vértices:</strong><br>';
        htmlProceso += 'Los vértices se encuentran en las intersecciones de las restricciones:<br>';
        htmlProceso += '- A: Origen (0, 0)<br>';
        htmlProceso += '- B: Intersección de x₁ = 0 y x₂ = 60 → (0, 60)<br>';
        htmlProceso += `- C: Intersección de R2 y R3 → (${restricciones_cruzada_presupuesto.toFixed(2)}, 60)<br>`;
        htmlProceso += `- D: Intersección de R1 y x₂ = 0 → (${punto_corte_primera_restriccion_lujo.toFixed(2)}, 0)</li>`;
        
        htmlProceso += '<li style="margin-top: 15px;"><strong>Dirección de optimización:</strong><br>';
        htmlProceso += 'La función objetivo Z = 80,000x₁ + 50,000x₂ aumenta al moverse hacia arriba y a la derecha.<br>';
        htmlProceso += 'Las líneas de nivel (isolineas) muestran valores constantes de Z.</li>';
        htmlProceso += '</ol>';
        
        document.getElementById('procesoGrafica').innerHTML = htmlProceso;
        
        // Actualizar la solución óptima en la página
        document.getElementById('solucionOptima').innerHTML = `
            <strong>Solución Óptima:</strong> Vértice (${betterOption.x1}, ${betterOption.x2})<br>
            <strong>Interpretación:</strong> Construir ${Math.floor(betterOption.x1)} departamentos tipo A (lujo) y ${betterOption.x2} departamentos tipo B (estándar)<br>
            <strong>Ganancia máxima:</strong> Z = 80,000(${betterOption.x1}) + 50,000(${betterOption.x2}) = $${betterOption.ganancia.toLocaleString()} USD<br>
            <strong>Uso de recursos:</strong><br>
            - Terreno utilizado: ${(departamentos_tipo_lujo * betterOption.x1 + departamentos_tipo_estandar * betterOption.x2).toLocaleString()} m² de 10,000 m²<br>
            - Presupuesto utilizado: $${(presupuesto_por_departamento_tipo_lujo * betterOption.x1 + presupuesto_por_departamento_tipo_estandar * betterOption.x2).toLocaleString()} de $15,000,000
        `;


        // FORMA ESTÁNDAR - SISTEMA DE ECUACIONES

        // Variables del problema
        console.log("\n=== FORMA ESTÁNDAR ===");
        console.log("Variables de decisión:");
        console.log("  x₁ = Número de departamentos tipo A (lujo)");
        console.log("  x₂ = Número de departamentos tipo B (estándar)");
        console.log("\nVariables de holgura:");
        console.log("  s₁ = Terreno no utilizado (m²)");
        console.log("  s₂ = Presupuesto no utilizado ($)");
        console.log("  s₃ = Demanda no cubierta de tipo Estandar");

        // Sistema de ecuaciones
        console.log("\n=== SISTEMA DE ECUACIONES ===");
        console.log("Función objetivo:");
        console.log(`  Maximizar Z = ${ganancia_por_departamento_tipo_lujo}x₁ + ${ganancia_por_departamento_tipo_estandar}x₂ + 0s₁ + 0s₂ + 0s₃`);

        console.log("\nRestricciones (en forma de igualdades):");
        console.log(`  ${departamentos_tipo_lujo}x₁ + ${departamentos_tipo_estandar}x₂ + s₁ = ${terreno_disponible}`);
        console.log(`  ${presupuesto_por_departamento_tipo_lujo}x₁ + ${presupuesto_por_departamento_tipo_estandar}x₂ + s₂ = ${presupuesto_inicial}`);
        console.log(`  0x₁ + 1x₂ + s₃ = ${demanda_tipo_estandar}`);
        console.log("  x₁, x₂, s₁, s₂, s₃ ≥ 0");

        // Verificar con la solución óptima
        console.log(`\n=== VERIFICACIÓN CON LA SOLUCIÓN ÓPTIMA (${betterOption.x1}, ${betterOption.x2}) ==="`);
        const x1_optimo = betterOption.x1;
        const x2_optimo = betterOption.x2;

        // Calcular variables de holgura en el óptimo
        const s1_optimo = terreno_disponible - (departamentos_tipo_lujo * x1_optimo + departamentos_tipo_estandar * x2_optimo);
        const s2_optimo = presupuesto_inicial - (presupuesto_por_departamento_tipo_lujo * x1_optimo + presupuesto_por_departamento_tipo_estandar * x2_optimo);
        const s3_optimo = demanda_tipo_estandar - x2_optimo;

        console.log(`Variables en el óptimo:`);
        console.log(`  x₁ = ${x1_optimo} (departamentos tipo Lujo)`);
        console.log(`  x₂ = ${x2_optimo} (departamentos tipo Estandar)`);
        console.log(`  s₁ = ${s1_optimo} (terreno sobrante)`);
        console.log(`  s₂ = ${s2_optimo} (presupuesto sobrante)`);
        console.log(`  s₃ = ${s3_optimo} (demanda no cubierta)`);

        // FORMA MATRICIAL
        console.log("\n=== FORMA MATRICIAL ===");

        // Definir las matrices
        const c = [
            ganancia_por_departamento_tipo_lujo,
            ganancia_por_departamento_tipo_estandar,
            0,
            0,
            0
        ];

        const A = [
            [departamentos_tipo_lujo, departamentos_tipo_estandar, 1, 0, 0],
            [presupuesto_por_departamento_tipo_lujo, presupuesto_por_departamento_tipo_estandar, 0, 1, 0],
            [0, 1, 0, 0, 1]
        ];

        const b = [
            terreno_disponible,
            presupuesto_inicial,
            demanda_tipo_estandar
        ];

        console.log("Vector de coeficientes de la función objetivo (c):");
        console.log("c = [" + c.join(", ") + "]ᵀ");

        console.log("\nMatriz de coeficientes de las restricciones (A):");
        console.log("A = ");
        A.forEach(fila => {
            console.log("    [" + fila.map(val => val.toString().padStart(7)).join(", ") + "]");
        });

        console.log("\nVector de términos independientes (b):");
        console.log("b = [" + b.join(", ") + "]ᵀ");

        console.log("\nForma matricial compacta:");
        console.log("Maximizar: Z = cᵀx");
        console.log("Sujeto a: Ax = b");
        console.log("          x ≥ 0");
        console.log("\nDonde x = [x₁, x₂, s₁, s₂, s₃]ᵀ");

        // Verificación matricial con la solución óptima
        console.log("\n=== VERIFICACIÓN MATRICIAL ===");
        const x_optimo = [x1_optimo, x2_optimo, s1_optimo, s2_optimo, s3_optimo];

        console.log("Vector solución óptima:");
        console.log("x* = [" + x_optimo.join(", ") + "]ᵀ");

        // Calcular Ax para verificar que Ax = b
        console.log("\nVerificación Ax* = b:");
        A.forEach((fila, i) => {
            const resultado = fila.reduce((sum, val, j) => sum + val * x_optimo[j], 0);
            console.log(`Fila ${i+1}: ${resultado} = ${b[i]} ✓`);
        });

        // Calcular el valor óptimo Z = cᵀx
        const z_optimo = c.reduce((sum, val, i) => sum + val * x_optimo[i], 0);
        console.log(`\nValor óptimo: Z* = cᵀx* = ${z_optimo.toLocaleString()}`);
        
        // Actualizar proceso de conversión
        document.getElementById('procesoConversion').innerHTML = `
            <p><strong>La forma estándar requiere que todas las restricciones sean igualdades.</strong></p>
            <p>Para convertir las desigualdades en igualdades, agregamos <em>variables de holgura</em> (slack variables):</p>
            <ol>
                <li><strong>Restricción de terreno:</strong><br>
                    Original: 120x₁ + 80x₂ ≤ 10,000<br>
                    Agregamos s₁: 120x₁ + 80x₂ + s₁ = 10,000<br>
                    <em>s₁ representa los m² de terreno no utilizados</em></li>
                
                <li style="margin-top: 10px;"><strong>Restricción de presupuesto:</strong><br>
                    Original: 200,000x₁ + 120,000x₂ ≤ 15,000,000<br>
                    Agregamos s₂: 200,000x₁ + 120,000x₂ + s₂ = 15,000,000<br>
                    <em>s₂ representa el presupuesto no utilizado en dólares</em></li>
                
                <li style="margin-top: 10px;"><strong>Restricción de demanda:</strong><br>
                    Original: x₂ ≤ 60<br>
                    Agregamos s₃: x₂ + s₃ = 60<br>
                    <em>s₃ representa la demanda no cubierta de departamentos tipo B</em></li>
            </ol>
            <p><strong>Las variables de holgura también deben ser no negativas:</strong> s₁, s₂, s₃ ≥ 0</p>
        `;
        
        // Actualizar la forma estándar en la página
        document.getElementById('formaEstandar').innerHTML = `
            <strong>Variables de decisión:</strong><br>
            x₁ = Número de departamentos tipo A (lujo)<br>
            x₂ = Número de departamentos tipo B (estándar)<br><br>
            <strong>Variables de holgura:</strong><br>
            s₁ = Terreno no utilizado (m²)<br>
            s₂ = Presupuesto no utilizado ($)<br>
            s₃ = Demanda no cubierta de tipo B<br><br>
            <strong>Función objetivo:</strong><br>
            Maximizar Z = ${ganancia_por_departamento_tipo_lujo.toLocaleString()}x₁ + ${ganancia_por_departamento_tipo_estandar.toLocaleString()}x₂ + 0s₁ + 0s₂ + 0s₃<br><br>
            <strong>Restricciones (forma de igualdades):</strong><br>
            ${departamentos_tipo_lujo}x₁ + ${departamentos_tipo_estandar}x₂ + s₁ = ${terreno_disponible.toLocaleString()}<br>
            ${presupuesto_por_departamento_tipo_lujo.toLocaleString()}x₁ + ${presupuesto_por_departamento_tipo_estandar.toLocaleString()}x₂ + s₂ = ${presupuesto_inicial.toLocaleString()}<br>
            0x₁ + 1x₂ + s₃ = ${demanda_tipo_estandar}<br>
            x₁, x₂, s₁, s₂, s₃ ≥ 0
        `;
        
        // Actualizar la forma matricial en la página
        document.getElementById('formaMatricial').innerHTML = `
            <strong>Maximizar:</strong> Z = cᵀx<br>
            <strong>Sujeto a:</strong> Ax = b, x ≥ 0<br><br>
            <strong>Donde:</strong><br>
            x = [x₁, x₂, s₁, s₂, s₃]ᵀ<br><br>
            c = [${c.map(v => v.toLocaleString()).join(', ')}]ᵀ<br><br>
            A = [${departamentos_tipo_lujo.toString().padStart(7)}, ${departamentos_tipo_estandar.toString().padStart(7)}, 1, 0, 0]<br>
                [${presupuesto_por_departamento_tipo_lujo.toLocaleString().padStart(7)}, ${presupuesto_por_departamento_tipo_estandar.toLocaleString().padStart(7)}, 0, 1, 0]<br>
                [      0,      1, 0, 0, 1]<br><br>
            b = [${b.map(v => v.toLocaleString()).join(', ')}]ᵀ
        `;

        console.log("\n=== MÉTODO SIMPLEX ===");

        // Clase para manejar el método Simplex
        class Simplex {
            constructor(tabla) {
                this.tabla = tabla;
                this.iteracion = 0;
            }

            // Imprimir tabla formateada
            imprimirTabla() {
                console.log(`\n--- Iteración ${this.iteracion} ---`);
                console.log("Base |     x₁    |     x₂    |   s₁  |   s₂  |   s₃  |      b");
                console.log("-".repeat(65));
                
                this.tabla.forEach(fila => {
                    const [base, ...valores] = fila;
                    const valoresFormateados = valores.map(v => 
                        typeof v === 'number' ? v.toFixed(0).padStart(10) : v.toString().padStart(10)
                    );
                    console.log(`${base.padEnd(4)} |${valoresFormateados.join(" |")}`);
                });
            }

            // Verificar si es óptima
            esOptima() {
                return this.tabla[0].slice(1, 6).every(v => v >= 0);
            }

            // Encontrar columna pivote (variable entrante)
            encontrarColumnaPivote() {
                let minValor = 0;
                let columna = -1;
                
                for (let j = 1; j <= 5; j++) {
                    if (this.tabla[0][j] < minValor) {
                        minValor = this.tabla[0][j];
                        columna = j;
                    }
                }
                
                return columna;
            }

            // Encontrar fila pivote (variable saliente)
            encontrarFilaPivote(columnaPivote) {
                let minCociente = Infinity;
                let fila = -1;
                
                for (let i = 1; i < this.tabla.length; i++) {
                    const a = this.tabla[i][columnaPivote];
                    const b = this.tabla[i][6];
                    
                    if (a > 0) {
                        const cociente = b / a;
                        if (cociente < minCociente) {
                            minCociente = cociente;
                            fila = i;
                        }
                    }
                }
                
                return fila;
            }

            // Realizar operación de pivoteo
            pivotear(filaPivote, columnaPivote) {
                const nuevaTabla = this.tabla.map(fila => [...fila]);
                const elementoPivote = this.tabla[filaPivote][columnaPivote];
                
                // Actualizar variable básica
                const variablesNombres = ["", "x₁", "x₂", "s₁", "s₂", "s₃"];
                nuevaTabla[filaPivote][0] = variablesNombres[columnaPivote];
                
                // Dividir fila pivote por elemento pivote
                for (let j = 1; j <= 6; j++) {
                    nuevaTabla[filaPivote][j] = this.tabla[filaPivote][j] / elementoPivote;
                }
                
                // Hacer ceros en la columna pivote
                for (let i = 0; i < nuevaTabla.length; i++) {
                    if (i !== filaPivote) {
                        const factor = this.tabla[i][columnaPivote];
                        for (let j = 1; j <= 6; j++) {
                            nuevaTabla[i][j] = this.tabla[i][j] - factor * nuevaTabla[filaPivote][j];
                        }
                    }
                }
                
                this.tabla = nuevaTabla;
                this.iteracion++;
            }

            // Resolver el problema completo
            resolver() {
                this.imprimirTablaConHTML();
                
                while (!this.esOptima()) {
                    console.log("\nLa solución NO es óptima. Continuando...");
                    
                    // Encontrar pivote
                    const columnaPivote = this.encontrarColumnaPivote();
                    const filaPivote = this.encontrarFilaPivote(columnaPivote);
                    
                    const variablesNombres = ["", "x₁", "x₂", "s₁", "s₂", "s₃"];
                    console.log(`Variable entrante: ${variablesNombres[columnaPivote]}`);
                    console.log(`Variable saliente: ${this.tabla[filaPivote][0]}`);
                    console.log(`Elemento pivote: ${this.tabla[filaPivote][columnaPivote]}`);
                    
                    // Agregar info de pivoteo al HTML
                    this.tablasHTML += `<p><strong>Variable entrante:</strong> ${variablesNombres[columnaPivote]}<br>`;
                    this.tablasHTML += `<strong>Variable saliente:</strong> ${this.tabla[filaPivote][0]}<br>`;
                    this.tablasHTML += `<strong>Elemento pivote:</strong> ${this.tabla[filaPivote][columnaPivote]}</p>`;
                    
                    // Pivotear
                    this.pivotear(filaPivote, columnaPivote);
                    this.imprimirTablaConHTML();
                }
                
                console.log("\n¡SOLUCIÓN ÓPTIMA ENCONTRADA!");
                this.tablasHTML += '<p style="color: green; font-weight: bold;">¡SOLUCIÓN ÓPTIMA ENCONTRADA!</p>';
                this.mostrarSolucion();
            }

            // Mostrar solución final
            mostrarSolucion() {
                console.log("\n=== SOLUCIÓN FINAL ===");
                
                const solucion = {
                    x1: 0, x2: 0, s1: 0, s2: 0, s3: 0
                };
                
                // Leer valores de variables básicas
                for (let i = 1; i < this.tabla.length; i++) {
                    const variable = this.tabla[i][0];
                    const valor = this.tabla[i][6];
                    
                    console.log(`${variable} = ${valor}`);
                    
                    switch(variable) {
                        case "x₁": solucion.x1 = valor; break;
                        case "x₂": solucion.x2 = valor; break;
                        case "s₁": solucion.s1 = valor; break;
                        case "s₂": solucion.s2 = valor; break;
                        case "s₃": solucion.s3 = valor; break;
                    }
                }
                
                const z = this.tabla[0][6];
                
                console.log(`\nValor óptimo: Z = $${z.toLocaleString()}`);
                console.log("\nInterpretación:");
                console.log(`- Construir ${solucion.x1} departamentos tipo A`);
                console.log(`- Construir ${solucion.x2} departamentos tipo B`);
                console.log(`- Ganancia total: $${z.toLocaleString()}`);
                console.log(`- Terreno sobrante: ${solucion.s1} m²`);
                console.log(`- Presupuesto sobrante: $${solucion.s2}`);
                
                // Guardar la solución para usar en la página
                this.solucionFinal = solucion;
                this.valorOptimo = z;
            }
            
            // Método para obtener el HTML de todas las tablas
            obtenerHTMLTablas() {
                return this.tablasHTML || '';
            }
            
            // Modificar imprimirTabla para guardar HTML
            imprimirTablaConHTML() {
                this.imprimirTabla();
                
                // Crear HTML de la tabla
                let html = `<h5>Iteración ${this.iteracion}:</h5>`;
                html += '<table style="border-collapse: collapse; margin: 10px 0;">';
                html += '<tr style="background-color: #ddd;">';
                html += '<th style="border: 1px solid #666; padding: 5px;">Base</th>';
                html += '<th style="border: 1px solid #666; padding: 5px;">x₁</th>';
                html += '<th style="border: 1px solid #666; padding: 5px;">x₂</th>';
                html += '<th style="border: 1px solid #666; padding: 5px;">s₁</th>';
                html += '<th style="border: 1px solid #666; padding: 5px;">s₂</th>';
                html += '<th style="border: 1px solid #666; padding: 5px;">s₃</th>';
                html += '<th style="border: 1px solid #666; padding: 5px;">b</th>';
                html += '</tr>';
                
                this.tabla.forEach((fila, index) => {
                    const [base, ...valores] = fila;
                    html += '<tr>';
                    html += `<td style="border: 1px solid #666; padding: 5px; font-weight: bold;">${base}</td>`;
                    valores.forEach(v => {
                        const valor = typeof v === 'number' ? v.toFixed(0) : v;
                        html += `<td style="border: 1px solid #666; padding: 5px; text-align: right;">${valor}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</table>';
                
                if (!this.tablasHTML) this.tablasHTML = '';
                this.tablasHTML += html;
            }
        }

        // Usar la clase Simplex
        const tablaInicial = [
            ["Z", -ganancia_por_departamento_tipo_lujo, -ganancia_por_departamento_tipo_estandar, 0, 0, 0, 0],
            ["s₁", departamentos_tipo_lujo, departamentos_tipo_estandar, 1, 0, 0, terreno_disponible],
            ["s₂", presupuesto_por_departamento_tipo_lujo, presupuesto_por_departamento_tipo_estandar, 0, 1, 0, presupuesto_inicial],
            ["s₃", 0, 1, 0, 0, 1, demanda_tipo_estandar]
        ];

        const simplex = new Simplex(tablaInicial);
        simplex.resolver();
        
        // Actualizar análisis de vértices
        let htmlVertices = '<table style="width: 100%; border-collapse: collapse;">';
        htmlVertices += '<tr style="background-color: #e0e0e0;">';
        htmlVertices += '<th style="border: 1px solid #999; padding: 8px;">Vértice</th>';
        htmlVertices += '<th style="border: 1px solid #999; padding: 8px;">Coordenadas (x₁, x₂)</th>';
        htmlVertices += '<th style="border: 1px solid #999; padding: 8px;">Factible</th>';
        htmlVertices += '<th style="border: 1px solid #999; padding: 8px;">Z = 80,000x₁ + 50,000x₂</th>';
        htmlVertices += '<th style="border: 1px solid #999; padding: 8px;">Observaciones</th>';
        htmlVertices += '</tr>';
        
        verticesCandidatos.forEach(vertice => {
            const resultado = esPuntoFactible(vertice.x1, vertice.x2);
            const ganancia = calcularGanancia(vertice.x1, vertice.x2);
            const esOptimo = vertice.x1 === betterOption.x1 && vertice.x2 === betterOption.x2;
            
            htmlVertices += `<tr style="${esOptimo ? 'background-color: #ffe066;' : ''}">`;
            htmlVertices += `<td style="border: 1px solid #999; padding: 8px;">${vertice.nombre}</td>`;
            htmlVertices += `<td style="border: 1px solid #999; padding: 8px;">(${vertice.x1}, ${vertice.x2})</td>`;
            htmlVertices += `<td style="border: 1px solid #999; padding: 8px; text-align: center;">${resultado.esFactible ? '✓' : '✗'}</td>`;
            htmlVertices += `<td style="border: 1px solid #999; padding: 8px; text-align: right;">$${ganancia.toLocaleString()}</td>`;
            htmlVertices += `<td style="border: 1px solid #999; padding: 8px;">`;
            
            if (esOptimo) {
                htmlVertices += '<strong>SOLUCIÓN ÓPTIMA</strong>';
            } else if (!resultado.esFactible) {
                if (!resultado.detalles.terreno) htmlVertices += 'Excede terreno. ';
                if (!resultado.detalles.presupuesto) htmlVertices += 'Excede presupuesto. ';
                if (!resultado.detalles.demanda) htmlVertices += 'Excede demanda.';
            } else {
                htmlVertices += 'Factible';
            }
            
            htmlVertices += '</td></tr>';
        });
        
        htmlVertices += '</table>';
        htmlVertices += '<p><em>El vértice destacado en amarillo es la solución óptima del problema.</em></p>';
        
        document.getElementById('analisisVertices').innerHTML = htmlVertices;
        
        // Actualizar proceso Simplex
        document.getElementById('procesoSimplex').innerHTML = simplex.obtenerHTMLTablas();
        
        // Actualizar la solución del problema en la página
        document.getElementById('solucionProblema').innerHTML = `
            <strong>Solución Óptima Encontrada:</strong><br>
            - x₁ = ${betterOption.x1} (departamentos tipo A)<br>
            - x₂ = ${betterOption.x2} (departamentos tipo B)<br>
            - s₁ = ${s1_optimo.toLocaleString()} m² (terreno sobrante)<br>
            - s₂ = $${s2_optimo.toLocaleString()} (presupuesto sobrante)<br>
            - s₃ = ${s3_optimo} (capacidad no utilizada de tipo B)<br><br>
            <strong>Valor Óptimo de la Función Objetivo:</strong><br>
            Z = $${betterOption.ganancia.toLocaleString()} USD<br><br>
            <strong>Interpretación de la Solución:</strong><br>
            Para maximizar las ganancias, la empresa debe construir ${Math.floor(betterOption.x1)} departamentos de lujo (tipo A) 
            y ${betterOption.x2} departamentos estándar (tipo B). Esto generará una ganancia total de $${betterOption.ganancia.toLocaleString()} USD.<br><br>
            <strong>Análisis de Recursos:</strong><br>
            - Se utilizará el ${((departamentos_tipo_lujo * betterOption.x1 + departamentos_tipo_estandar * betterOption.x2) / terreno_disponible * 100).toFixed(1)}% del terreno disponible<br>
            - Se utilizará el ${((presupuesto_por_departamento_tipo_lujo * betterOption.x1 + presupuesto_por_departamento_tipo_estandar * betterOption.x2) / presupuesto_inicial * 100).toFixed(1)}% del presupuesto disponible<br>
            - Se alcanzará el 100% de la demanda máxima de departamentos tipo B
        `;
    </script>
</body>
</html>